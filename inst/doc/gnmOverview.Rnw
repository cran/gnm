%\VignetteIndexEntry{gnmOverview}
%\VignetteDepends{gtools}
%\VignetteKeywords{Generalized Nonlinear Models}
%\VignettePackage{gnm}

\documentclass[a4paper]{article}

\usepackage{Sweave}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{times}
\usepackage{courier}
\usepackage{booktabs}
\usepackage[round,authoryear]{natbib}
\usepackage[left=2cm,top=3cm,nohead]{geometry}
\usepackage{hyperref}
\usepackage{moreverb}

\setkeys{Gin}{width=0.6\textwidth}

%% The next few definitions from "Writing Vignettes for Bioconductor Packages"
%% by R Gentleman
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\textit{#1}}}
\newcommand{\Rfunarg}[1]{{\textit{#1}}}

\newcommand\twiddle{{\char'176}}

%\setlength{\oddsidemargin}{0.5in}
%\setlength{\evensidemargin}{0.5in}
%\setlength{\textwidth}{5.5in}

\title{Generalized nonlinear models in R: an overview of the
\textbf{\Rpackage{gnm}} package}

\author{Heather Turner and David Firth\footnote{
This work was supported by the Economic and Social Research Council (UK)
through a Professorial Fellowship.}\\
\emph{University of Warwick, UK}
}

\date{For \Rpackage{gnm} version \Sexpr{packageDescription("gnm")[["Version"]]} , \Sexpr{Sys.Date()}}

\begin{document}
\maketitle

{\small
 \tableofcontents
}

\section{Introduction}

The \Rpackage{gnm} package provides facilities for fitting
\emph{generalized nonlinear models}, i.e., regression models in which the
link-transformed mean is described as a sum of predictor terms, some of
which may be non-linear in the unknown parameters.  Linear and generalized
linear models,
as handled by the \Rfunction{lm} and \Rfunction{glm} functions in R, are
included in the class
of generalized nonlinear models, as the special case in which there is no
nonlinear term.

This document gives an extended overview of the \Rpackage{gnm} package, with
some examples of applications.  The primary package documentation in the
form of standard help pages, as viewed in R by, for example, \texttt{?gnm} or
\texttt{help(gnm)}, is supplemented rather than replaced by the present
document.

We begin below with a preliminary note (Section \ref{glms}) on ways in which
the \Rpackage{gnm} package extends R's facilities for specifying, fitting
and working with generalized \emph{linear} models.  Then (Section
\ref{nonlinear} onwards) the facilities for nonlinear terms are introduced,
explained and exemplified.

The \Rpackage{gnm} package is installed in the standard way for CRAN packages,
for example by using \Rfunction{install.packages}.  Once installed, the
package is loaded into an R session by
<<Load_gnm>>=
library(gnm)
@

\section{Generalized Linear Models}
\label{glms}

\subsection{Preamble}

Central to the facilities provided by the \Rpackage{gnm} package is the
model-fitting function \Rfunction{gnm}, which interprets a model formula
and returns a model object.  The user interface of \Rfunction{gnm} is patterned
after \Rfunction{glm} (which is included in R's standard \Rpackage{stats}
package), and indeed
\Rfunction{gnm} can be viewed as a replacement for
\Rfunction{glm} for specifying and fitting generalized linear models.
In general there is no reason to prefer \Rfunction{gnm} to \Rfunction{glm} for
fitting generalized linear models, except perhaps when the model involves a
large number of incidental parameters which are treatable
by \Rfunction{gnm}'s \emph{eliminate} mechanism (see Section \ref{eliminate}).

While the main purpose of the \Rpackage{gnm} package is to extend the class of
models to include nonlinear terms, some of the new functions and methods
can be used also with the familiar \Rfunction{lm} and \Rfunction{glm}
model-fitting functions.  These are: three new data-manipulation functions
\Rfunction{Diag}, \Rfunction{Symm} and \Rfunction{Topo}, for setting up structured interactions between factors; a new \Rclass{family} function, 
\Rfunction{wedderburn},
for modelling a response variable in $[0,1]$ with the variance function
$V(\mu) = \mu^2(1-\mu)^2$ as in \citet{Wedd74};
and a new generic function \Rfunction{termPredictors} which
extracts the contribution of each term to the predictor from a fitted model
object.  These functions are briefly introduced here, before we move on to
nonlinear models in Section \ref{nonlinear}.

\subsection{\Rfunction{Diag} and \Rfunction{Symm}}

When dealing with \emph{homologous} factors, that is, categorical variables
whose levels are the same, statistical models often involve structured
interaction terms which exploit the inherent symmetry.  The functions
\Rfunction{Diag} and \Rfunction{Symm} facilitate the specification of such
structured interactions.

As a simple example of their use, consider the log-linear models of
\emph{quasi-independence}, \emph{quasi-symmetry} and \emph{symmetry}
for a square contingency table.  \citet{Agre02}, Section 10.4, gives data on
migration between regions of the USA between 1980 and 1985:
<<migrationData>>=
count <- c(11607,   100,   366,   124,
              87, 13677,   515,   302,
             172,   225, 17819,   270,
              63,   176,   286, 10192 )
region <- c("NE", "MW", "S", "W")
row <-  gl(4, 4, labels = region)
col <-  gl(4, 1, length = 16, labels = region)
@
The comparison of models reported by Agresti can be achieved as follows:
<<squareTableModels>>=
independence <- glm(count ~ row + col, family = poisson)
quasi.indep <- glm(count ~ row + col + Diag(row, col), family = poisson)
symmetry <- glm(count ~ Symm(row, col), family = poisson)
quasi.symm <- glm(count ~ row + col + Symm(row, col), family = poisson)
comparison1 <- anova(independence, quasi.indep, quasi.symm)
print(comparison1, digits = 7)
comparison2 <- anova(symmetry, quasi.symm)
print(comparison2)
@

The \Rfunction{Diag} and \Rfunction{Symm} functions also generalize the notions
of diagonal and symmetric interaction to cover situations involving more than
two homologous factors.

\subsection{\Rfunction{Topo}}

More general structured interactions than those provided by \Rfunction{Diag} 
and \Rfunction{Symm} can be specified using the function \Rfunction{Topo}.  
(The name of this function is short for `topological interaction', 
which is the nomenclature
often used in sociology for factor interactions with structure derived from
subject-matter theory.)

The \Rfunction{Topo} function operates on any number ($k$, say) 
of input factors, and
requires an argument named \Rfunarg{spec} which must be an array of
dimension $L_1 \times \ldots \times L_k$, where $L_i$ is the number of 
levels for the $i$th factor.  The \Rfunarg{spec} argument specifies
the interaction level corresponding to every possible combination of 
the input factors, and the result is a new factor representing the specified
interaction.

As an example, consider fitting the `log-multiplicative layer effects' models
described in \citet{Xie92}.  The data are 7 by 7 versions of social mobility
tables from \citet{Erik82}:
<<EriksonData>>=
data(erikson)
### Collapse to 7 by 7 table as in Erikson et al. (1982)
erikson <- as.data.frame(erikson)
lvl <- levels(erikson$origin)
levels(erikson$origin) <- levels(erikson$destination) <-
    c(rep(paste(lvl[1:2], collapse = " + "), 2), lvl[3],
      rep(paste(lvl[4:5], collapse = " + "), 2), lvl[6:9])
erikson <- xtabs(Freq ~ origin + destination + country, data = erikson)
@
From sociological theory --- for which see \citet{Erik82} or \citet{Xie92} --- 
the log-linear interaction between origin and destination is assumed to have
a particular structure:
\newpage
\begin{verbatim}
> levelMatrix <- matrix(c(2, 3, 4, 6, 5, 6, 6,
+                         3, 3, 4, 6, 4, 5, 6,
+                         4, 4, 2, 5, 5, 5, 5,
+                         6, 6, 5, 1, 6, 5, 2,
+                         4, 4, 5, 6, 3, 4, 5,
+                         5, 4, 5, 5, 3, 3, 5,
+                         6, 6, 5, 3, 5, 4, 1), 7, 7, byrow = TRUE)
\end{verbatim}  
The models of table 3 of \citet{Xie92} can now be fitted as follows:
\begin{verbatim}
> ## Null association between origin and destination
> nullModel <- gnm(Freq ~ country:origin + country:destination,
+                  family = poisson, data = erikson)
Running main iterations.
Done
> ## Interaction specified by levelMatrix, common to all countries
> commonTopo <- update(nullModel, ~ . +
+                      Topo(origin, destination, spec = levelMatrix))
Running main iterations.
Done
> ## Interaction specified by levelMatrix, different multiplier for each country
> multTopo <- update(nullModel, ~ . + Mult(country, Topo(origin, destination,
+                                       spec = levelMatrix)))
Running start-up iterations..
Running main iterations.......
Done
> ## Interaction specified by levelMatrix, different effects for each country
> separateTopo <- update(nullModel, ~ . +
+                        country:Topo(origin, destination, spec = levelMatrix))
Running main iterations.
Done
> 
> anova(nullModel, commonTopo, multTopo, separateTopo)
Analysis of Deviance Table

Model 1: Freq ~ country:origin + country:destination
Model 2: Freq ~ Topo(origin, destination, spec = levelMatrix) + country:origin + 
    country:destination
Model 3: Freq ~ Mult(country, Topo(origin, destination, spec = levelMatrix)) + 
    country:origin + country:destination
Model 4: Freq ~ country:origin + country:destination + country:Topo(origin, 
    destination, spec = levelMatrix)
  Resid. Df Resid. Dev  Df Deviance
1       108     4860.0             
2       103      244.3   5   4615.7
3       101      216.4   2     28.0
4        93      208.5   8      7.9
\end{verbatim}
Here we have used \Rfunction{gnm} to fit all of these log-link models; the 
first, second and fourth are log-linear and could equally well have been fitted
using \Rfunction{glm}.

\subsection{The \Rfunction{wedderburn} family}

In \citet{Wedd74} it was suggested to represent the mean of
a continuous response variable in
$[0,1]$ using a quasi-likelihood model with logit link and the
variance function $\mu^2(1-\mu)^2$.  This is not one of the variance
functions made available as standard in R's \Rfunction{quasi} family.  The
\Rfunction{wedderburn} family provides it.  As an example, Wedderburn's
analysis of data on leaf blotch on barley can be reproduced as follows:
<<wedderburn>>=
data(barley)  ##  data from Wedderburn (1974), see ?barley
logitModel <- glm(y ~ site + variety, family = wedderburn, data = barley)
fit <- fitted(logitModel)
print(sum((barley$y - fit)^2 / (fit * (1-fit))^2))
@
This agrees with the chi-squared value reported on page 331 of \citet{McCu89},
which differs slightly from Wedderburn's reported value.

\subsection{\Rfunction{termPredictors}}

The generic function \Rfunction{termPredictors} extracts a term-by-term
decomposition of the predictor function in a linear, generalized linear or
generalized nonlinear model.

As an illustrative example, we can decompose the linear predictor in the above
quasi-symmetry model as follows:
<<termPredictors>>=
print(temp <- termPredictors(quasi.symm))
rowSums(temp) - quasi.symm$linear.predictors
@

Such a decomposition might be useful, for example, in assessing the relative
contributions of different terms or groups of terms.

\section{Nonlinear Terms}
\label{nonlinear}

The \Rpackage{gnm} package provides a flexible framework for the specification
and
estimation of generalized models with nonlinear terms. Multiplicative
interaction terms can be estimated using the in-built capability of the
\Rfunction{gnm} function and are specified in the model formula using the symbolic
function \Rfunction{Mult}. Other nonlinear terms can be estimated using plug-in
functions for \Rfunction{gnm} and are specified using \Rfunction{Nonlin}.

There are two plug-in functions currently made available in
the \Rpackage{gnm} package: \Rfunction{MultHomog} for fitting multiplicative
interaction terms with homogeneous effects and \Rfunction{Dref} for fitting
diagonal reference terms. Users of \Rpackage{gnm} can define their own
custom plug-in functions to specify other types of nonlinear term.

\subsection{Multiplicative Interaction Terms using \Rfunction{Mult}}

Multiplicative interaction terms can be included in the formula argument to
\Rfunction{gnm} by using the symbolic wrapper function \Rfunction{Mult}.
Constituent multipliers\footnote{
A note on terminology: the rather cumbersome phrase `constituent multiplier', or
sometimes the abbreviation `multiplier', will
be used throughout this document in preference to the more elegant and standard
mathematical term `factor'.  This will avoid possible confusion with the 
completely different meaning of the word `factor' --- that is, a categorical 
variable --- in R.
}
in
the interaction are passed as unspecified arguments to \Rfunction{Mult} and are
expressed
by symbolic linear formulae. An intercept is automatically added to each
constituent multiplier unless otherwise specified. For example,
to fit the row-column association model
\[
\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c,
\]
also known as the Goodman RC model \citep{Good79}, the \Rfunarg{formula}
argument
of \Rfunction{gnm} would be
\begin{alltt}
    mu \twiddle\ R + C + Mult(-1 + R, -1 + C)
\end{alltt}
where \Robject{R} and \Robject{C} are row and column factors respectively.



\Rfunction{Mult} has one specified argument \Rfunarg{multiplicity}, which is
\Robject{1} by default. This argument determines the number of times that
the specified multiplicative structure appears in the model. For example,
\begin{alltt}
    mu \twiddle\ R + C + Mult(-1 + R, -1 + C, multiplicity = 2)
\end{alltt}
would give the RC(2) model \citep{Good79}
\[
\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c + \theta_r\phi_c.
\]

In some contexts, it may be desirable to constrain one or more of the
constituent multipliers so that it is always nonnegative.
This may be
achieved by specifying the multiplier as an exponential, as in the
following `uniform difference' model \citep{Xie92, Erik92}
\[
\log \mu_{rct} = \alpha_{rt} + \beta_{ct} + e^{\gamma_t}\delta_{rc}.
\]
Exponentiated constituent multipliers 
are specified in \Rclass{gnm} models using the symbolic
function \Rfunction{Exp}; for example, the uniform difference model above
would be specified by the formula
\begin{alltt}
    mu \twiddle\ R:T + C:T + Mult(Exp(-1 + T), R:C)
\end{alltt}

\subsection{Other Nonlinear Terms using \Rfunction{Nonlin}}

Nonlinear terms which can not be specified using \Rfunction{Mult} may be
specified using \Rfunction{Nonlin}. This symbolic function indicates a term
which requires a plug-in function to estimate the associated
parameters. \Rfunction{Nonlin} takes a single argument, which is a call to the
relevant plug-in function.  

For example, in the formula
\begin{alltt}
    mu ~ x + A + B + Nonlin(PlugInFunction(A, B, arg1 = x, arg2 = C))
\end{alltt}
the call to \Rfunction{Nonlin} is used to specify a term that requires the
plug-in function \Robject{PlugInFunction}.

The two plug-in functions already included in the
\Rpackage{gnm} package are described
below, followed by a guide to writing custom plug-in functions.

\subsubsection{\Rfunction{MultHomog}}

The \Rfunction{MultHomog} function provides the tools required to fit
multiplicative interaction terms with one component in which the constituent
multipliers are the effects of two or more factors and the effects of these
factors are constrained to be equal when the factor levels are equal. The
arguments of \Rfunction{MultHomog} are the factors in the interaction, which are
assumed to be objects of class \Rclass{factor}.

As an example, consider the following association model with homogeneous
row-column effects:
\[\log \mu_{rc} = \alpha_r + \beta_c + \theta_{r}I(r=c) + \gamma_r\gamma_c.\]
To fit this model, with response variable named \Robject{mu},
the formula argument to \Rfunction{gnm} would be
\begin{alltt}
    mu \twiddle\ R + C + Diag(R, C) + Nonlin(MultHomog(R, C))
\end{alltt}

If the factors passed to \Rfunction{MultHomog} do not have
exactly the same levels,
a common set of levels is obtained by taking the union of the levels of each
factor, sorted into increasing order.

\subsubsection{\Rfunction{Dref}}
\label{NonlinDref}

\Rfunction{Dref} is a plug-in function to fit diagonal reference terms involving
two or more factors with a common set of levels. A diagonal reference term
comprises an additive component for each factor. The component for factor $f$,
is given by
\[
w_f\gamma_l
\]
for an observation with level $l$ of factor $f$, where $w_f$ is the weight for
factor $f$ and $\gamma_l$ is the ``diagonal effect'' for level $l$.

The weights are constrained to be nonnegative and to sum to one so that a
``diagonal effect'', say $\gamma_l$, is the value of the diagonal reference term
for data points with level $l$ across the factors. \Rfunction{Dref} constrains
the weights by defining them as
\[
w_f = \frac{e^{\delta_f}}{\sum_i e^{\delta_i}}
\]
and estimating the $\delta_f$.

Factors in the interaction are passed to unspecified arguments of
\Rfunction{Dref}. For example, the following diagonal reference model for
a contingency table classified by the row factor \Robject{R}
and the column factor \Robject{C},
\[
\mu_{rc} =\frac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_r +
\frac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_c,
\]
would be specified by the formula
\begin{alltt}
    mu \twiddle\ -1 + Nonlin(Dref(R, C))
\end{alltt}

\Rfunction{Dref} has one specified argument \Rfunarg{formula}, which is a symbolic
description of the dependence of $\delta_f$ on any covariates.
For example, the formula
\begin{alltt}
    mu \twiddle\ -1 + x + Nonlin(Dref(R, C, formula = ~ 1 + x))
\end{alltt}
specifies the following diagonal reference model
\[
\mu_{rc} = \beta_Xx + \frac{e^{\xi_1 + \beta_1x}}{e^{\xi_1 + \beta_1x} + e^{\xi_2 + \beta_2x}}\gamma_r +
\frac{e^{\xi_2 + \beta_2x}}{e^{\xi_1 + \beta_x} + e^{\xi_2 + \beta_2x}}\gamma_c,
\]
The default value of \Rfunarg{formula} is \Robject{\twiddle 1}, so that
constant weights are estimated. The coefficients returned by \Rfunction{gnm} are
those that are directly estimated, i.e. the $\delta_f$ or the $\xi_f$ and
$\beta_f$, rather than the implied weights $w_f$.

\subsubsection{Custom Plug-in Functions}

Custom plug-in functions may be written to enable \Rfunction{gnm} to fit
nonlinear terms that can not be specified by \Rfunction{Mult}
or the plug-in functions provided by the \Rpackage{gnm} package.

There are no constraints on the arguments that a plug-in function may
take.  However it is important that \Rfunction{Nonlin}, when given a call to the
plug-in function, can determine the variables that are in the term, so that these
variables can be added to the model frame. By default, expressions passed to
unspecified arguments of the plug-in function are assumed to represent the
variables in the term. 

If the default action of \Rfunction{Nonlin} will not capture the required
variables, a companion function must exist (in the environment of the
plug-in function), which takes the same arguments as the plug-in function and
returns deparsed expressions representing the necessary variables. The name of
this function must be the name of the plug-in function suffixed with
"Variables". For example, the (non-visible) companion function for
\Rfunction{Dref} is defined as
\begin{verbatim}
    DrefVariables <- function(..., formula = ~ 1) {
        as.character(c(match.call(expand.dots = FALSE)[[2]], formula[[2]]))
    }
\end{verbatim}
returning the expressions passed to unspecified arguments and the right-hand
side of the formula passed to \Rfunarg{formula}, as character strings. For
instance 
@ 
<<DrefVariables_example>>=
gnm:::DrefVariables(A, B, formula = ~ 1 + C)
@ %def 
from which \Rfunction{Nonlin} will know that \Robject{A}, \Robject{B} and
\Robject{C} need to be added to the model frame.

The call to the plug-in function is evaluated in the environment of
the model frame and in the enclosing environment of the parent frame
of the call to \Rfunction{gnm}. This should ensure that variables passed
directly to the plug-in function can be found. However, to evaluate variables
within the plug-in function, it may be necessary to access the model frame,
which can be obtained using the function \Rfunction{getModelFrame}.

For example, the factors in a \Rfunction{Dref} term are passed directly to
unspecified arguments, so the dummy variables for these factors can be found as
follows 
\begin{alltt}
    # get design matrices for Dref factors
    designList <- lapply(list(...), class.ind)
\end{alltt}
But any covariates on which the weights depend are only represented symbolically
in the \Rfunarg{formula} argument, so the design matrix for these variables must
be found in the context of the model frame
\begin{alltt}
    ## get design matrix for local structure
    gnmData <- getModelFrame()
    local <- model.matrix(formula, data = gnmData)   
\end{alltt}

The plug-in function should return a list with at least the following 
three components:
\begin{description}
\item[\Robject{labels}]
  a character vector of labels for the
  parameters (to which \Rfunction{gnm} will prefix the call to the
  plug-in function).
\item[\Robject{predictor}]
  a function which takes a vector of parameter estimates
  and returns either a vector of fitted values or a matrix whose columns are
  additive components of the fitted values.
\item[\Robject{localDesignFunction}]
  a function which takes the specified
  arguments \Rfunarg{coef} (a vector of parameter estimates) and
  \Rfunarg{predictor} (the result of the predictor function), and
  returns the local design matrix.
\end{description}
and optionally one further component
\begin{description}
\item[\Robject{start}]
  a vector of default starting values for the
  parameters. \Robject{NA} may be used to indicate parameters which
  may be treated as linear for the purpose of finding starting
  values, given the non-\Robject{NA} values. See Section \ref{start} for details of
  how these starting values will be used if provided and the generic default
  values that will be used otherwise. 
\end{description}

As an example of a \Robject{start} component, \Rfunction{Dref} simply returns
\begin{alltt}
    rep(0.5, length(labels))
\end{alltt}
where \Robject{labels} is the vector of parameter labels to be returned as the
\Robject{labels} component, for instance
\begin{alltt}
    c("A", "B", "1", "2", "3", "4", "5", "6", "7")
\end{alltt}

The \Rfunction{MultHomog} function provides a simple example of a
\Robject{predictor} component:
\begin{alltt}
    predictor <- function(coef) \{
        do.call("pprod", lapply(designList, "%*%", coef))
    \}
\end{alltt}
which computes the product of the vectors found by multiplying the design matrix
for each factor in the interaction (held in \Robject{designList}) by the
homogeneous coefficients (in \Robject{coef}). This function takes advantage of
\emph{lexical scoping}: \Robject{designList} is an object defined in
\Rfunction{MultHomog}, which \Rfunction{predictor} is able to find because
\Rfunction{predictor} is also defined in \Rfunction{MultHomog} and hence
\Rfunction{MultHomog} is the enclosing environment of \Rfunction{predictor}.

The \Rfunction{localDesignFunction} created by \Rfunction{MultHomog}
is slightly more complicated:
\begin{alltt}
    localDesignFunction <- function(coef, ...) \{
        productList <- designList
        for (i in seq(designList))
            productList[[i]] <- designList[[i]] *
                drop(do.call("pprod", lapply(designList[-i], "%*%", coef)))
        do.call("psum", productList)
    \}
\end{alltt}
This function only uses the argument \Rfunarg{coef}, but since the
local design function returned by a plug-in function must also accept the
argument \Rfunarg{predictor}, further arguments are allowed by the use of the
special argument `\Robject{...}'.

\section{Controlling the Fitting Procedure}

The \Rfunction{gnm} function has a number of arguments
which affect the way a model will be
fitted.  Basic control parameters and starting values can be set by
\Rfunarg{control} and \Rfunarg{start} respectively. Parameters can be
constrained
to zero by specifying a \Rfunarg{constrain} argument. Finally parameters of a
stratification factor can be handled more efficiently by specifying the term in
an \Rfunarg{eliminate} argument. These options are described in more detail
below.

\subsection{Using \Rfunarg{control} with \Rfunction{gnmControl}}

The \Rfunarg{control} argument provides a way to specify the tolerance level for
convergence, the number of starting iterations and the maximum number of main
iterations, as well as the option to trace the deviance throughout the fitting
process.  By default, the \Rfunarg{control} argument is a call to
\Rfunction{gnmControl} using any arguments passed on from
\Rfunction{gnm}. The \Rfunction{gnmControl} function
creates a list of the control
parameters, including any at their default values. For example
\begin{alltt}
    gnm(mu \twiddle\ R + C + Mult(-1 + R, -1 + C), tolerance = 1e-6,
    iterStart = 3)
\end{alltt}
is equivalent to
\begin{alltt}
    gnm(mu \twiddle\ R + C + Mult(-1 + R, -1 + C),
        control = gnmControl(tolerance = 1e-6, iterStart = 3))
\end{alltt}
which is the same as
\begin{alltt}
    gnm(mu \twiddle\ R + C + Mult(-1 + R, -1 + C),
        control = list(tolerance = 1e-6, iterStart = 3, iterMax = 500,
        trace = FALSE))
\end{alltt}

\subsection{Using \Rfunarg{start}}
\label{start}

In some contexts, the default starting values may not be appropriate and the
algorithm will fail to converge, or perhaps only converge after a large number
of iterations. Alternative starting values may be passed on to \Rfunction{gnm}
by
specifying a \Rfunarg{start} argument. This should be a numeric vector of length
equal to the number of parameters (or possibly the non-eliminated parameters,
see Section \ref{eliminate}), however missing starting values (\Robject{NA}s)
are allowed.

If there is no user-specified starting value for a parameter, the
default value is used. This feature is particularly useful when adding terms to
a model, since the estimates from the original model can be used as starting
values, as in this example:
\begin{alltt}
    model1 <- gnm(mu \twiddle\ R + C + Mult(-1 + R, -1 + C))
    model2 <- gnm(mu \twiddle\ R + C + Mult(-1 + R, -1 + C, multiplicity = 2),
                  start = c(coef(model1), rep(NA, 10))
\end{alltt}
The \Rfunction{gnm} call can be made with
\texttt{method = "coef"} to identify the
parameters of a model prior to estimation, to assist with the specification of
arguments such as \Rfunarg{start}.

The starting procedure used by \Rfunction{gnm} is as follows
\begin{enumerate}
\item
Generate starting values $\theta_i$ for all parameters $i = 1, \ldots, p$ from
the Uniform($-0.1$, $0.1$) distribution. Shift these values away from zero as
follows
\begin{equation*}
\theta_i = \begin{cases}
    \theta_i - 0.1 &  \text{if } \theta_i < 1 \\
    \theta_i + 0.1 & \text{otherwise}
\end{cases}
\end{equation*}
\item
Replace generic starting values with default starting values set by plug-in
functions, where applicable.
\item
Replace default starting values with any starting values specified by the
\Rfunarg{start} argument of \Rfunction{gnm}. 
\item
Compute the \Rfunction{glm} estimate of any parameters that may be treated as
linear (i.e. those in linear terms or those with a default starting value of
\Robject{NA} set by a plug-in function), offsetting the contribution to
the predictor of any parameters specified by \Rfunarg{start} or a plug-in
function. 
\item
Run starting iterations: update one at a time any remaining nonlinear parameters
not specified by \Rfunarg{start} or a plug-in function, updating \emph{all}
parameters that may be treated as linear after each round of updates. 
\end{enumerate}
Note that no starting iterations (step 5) will be run if all
parameters are specified by \Rfunarg{start} or a plug-in function.

\subsection{Using \Rfunarg{constrain}}
\label{constrain}

By default, \Rfunction{gnm}
only imposes identifiability constraints on any linear
terms in the model to be fitted.
For these terms, the constraints are determined
in the same way as they would be in \Rfunction{glm}. Any nonlinear terms will
usually be
over-parameterized unless constraints are imposed by the defining plug-in
function (as in the case of \Rfunction{Dref}, for example). For a model with
nonlinear terms that are over-parameterized, \Rfunction{gnm}
will return a random parameterisation.

To illustrate this point, consider the following application of \Rfunction{gnm},
discussed later in Section \ref{RCmodels}:
<<RC_homogeneous_model_1>>=
data(occupationalStatus)
set.seed(1)
RChomog1 <- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               Nonlin(MultHomog(origin, destination)), family = poisson,
               data = occupationalStatus)
@
Running the analysis again from a different seed
<<RC_homogeneous_model_2>>=
set.seed(2)
RChomog2 <- eval(RChomog1$call)
@
gives a different representation of the same model:
<<Compare_coefficients>>=
compareCoef <- cbind(coef(RChomog1), coef(RChomog2))
colnames(compareCoef) <- c("RChomog1", "RChomog2")
compareCoef
@
Even though the linear terms are constrained, the parameter estimates for
these terms still change, because these terms are aliased with the higher order
multiplicative interaction, which is unconstrained.

Additional constraints may be specified through the \Rfunarg{constrain} argument
of \Rfunction{gnm}. This argument indicates parameters that are to be
constrained
to zero in the fitting process. Parameters can be indicated by a logical vector,
a vector of indices or, if \texttt{constrain = "pick"} they can be selected
through a \emph{Tk} dialog.

In the case above, constraining one level of the homogeneous multiplicative
factor is sufficient to make the parameters of the nonlinear term
identifiable, and hence all parameters in the model identifiable. For example,
setting the last level of the homogeneous multiplicative factor to zero,
<<RC_homogeneous_constrained_model>>=
multCoef <- coef(RChomog1)[grep("Mult", names(coef(RChomog1)))]
set.seed(1)
RChomogConstrained1 <- update(RChomog1, constrain = 31,
                              start = c(rep(NA, 23), multCoef - multCoef[8]))
set.seed(2)
RChomogConstrained2 <- eval(RChomogConstrained1$call)
identical(coef(RChomogConstrained1), coef(RChomogConstrained2))
@
gives the same results regardless of the random seed set beforehand.

It is not usually so straightforward to constrain all the parameters in a
generalized nonlinear model. However, the simple constraints imposed by
\Rfunarg{constrain} are often sufficient to make particular coefficients of
interest identifiable. The functions \Rfunction{checkEstimable} or
\Rfunction{getContrasts}, described in Section \ref{Methods},
may be used to check
whether particular contrasts are estimable.

\subsection{Using \Rfunarg{eliminate}}
\label{eliminate}

Sometimes a model will include a ``stratification'' factor which identifies
units for which a unit-specific intercept should be estimated. It is often the
case that such factors have a large number of levels and though they are
required in the model, are not of direct interest in themselves.

The \Rfunarg{eliminate} argument of \Rfunction{gnm} can be used to specify a
stratification factor in a model, so that the factor can be handled more
efficiently. The factor should be specified by a formula with no response
variable and with terms spanning the space of a single factor, i.e., a factor, an
interaction between factors, or crossed factors, for example
\begin{alltt}
    gnm(mu ~ -1 + strata1*strata2 + A + B + Mult(A, B), eliminate = ~ strata1*strata2)
\end{alltt}
The use of \Rfunarg{eliminate} makes the specification of a
stratification factor
in the model formula redundant, so the above call is equivalent to
\begin{alltt}
    gnm(mu ~ -1 + A + B + Mult(A, B), eliminate = ~ strata1*strata2)
\end{alltt}
or even
\begin{alltt}
    gnm(mu ~ A + B + Mult(A, B), eliminate = ~ strata1*strata2)
\end{alltt}
since no intercept is fitted when a formula is passed to \Rfunarg{eliminate}.

Specifying a stratification factor through \Rfunarg{eliminate} has two
advantages. First, computational speed is improved --- substantially
so if the number of eliminated parameters is large. Second, the eliminated
parameters are excluded from summaries of the model so that they focus on the
coefficients of interest.

The \Rfunarg{eliminate} feature is useful, for example, when
multinomial-response models are fitted by using the well known equivalence
between multinomial and (conditional) Poisson likelihoods.  In such situations
the sufficient statistic involves a potentially large number of fixed
multinomial row totals, and the corresponding parameters are of no
substantive interest.  For an example see Section \ref{Stereotype} below.

The  \Rfunarg{eliminate} feature as implemented in \Rpackage{gnm} extends the 
earlier work of \cite{Hatz04} to a broader class of models and to 
over-parameterized model representations.

\section{Methods and Accessor functions}
\label{Methods}

The \Rfunction{gnm} function returns
an object of class \Robject{c("gnm", "glm", "lm")}. There
are several methods that have been written for objects of class \Rclass{glm}
or \Rclass{lm} to facilitate inspection of fitted models.
Out of the generic functions in the \Rpackage{base},
\Rpackage{stats} and \Rpackage{graphics} packages for which methods have been
written
for \Rclass{glm} or \Rclass{lm} objects, Figure \ref{glm.lm} shows those
that can be used to analyse \Rclass{gnm} objects, whilst Figure
\ref{!glm.lm} shows
those that are not implemented for \Rclass{gnm} objects.

\begin{figure}[!tbph]
    \centering
    \begin{fbox}
        {
          \begin{tabular*}{7.5cm}{@{\extracolsep{\fill}}lll@{\extracolsep{\fill}}}
              anova	&	hatvalues	&	residuals	\\
              case.names	&	influence	&	rstandard	\\
              coef	&	labels	&	summary	\\
              cooks.distance	&	logLik	&	variable.names	\\
              deviance	&	model.frame	&	vcov	\\
              extractAIC	&	model.matrix	&	weights	\\
              family	&	plot	&		\\
              formula	&	print	&		\\

          \end{tabular*}
        }
    \end{fbox}
    \caption{Generic functions in the \Rpackage{base}, \Rpackage{stats} and
      \Rpackage{graphics} packages that can be used to analyse
      \Rclass{gnm} objects.}
    \label{glm.lm}
\end{figure}

\begin{figure}[!tbph]
    \centering
    \begin{fbox}
        {
          \begin{tabular*}{4.5cm}{@{\extracolsep{\fill}}ll@{\extracolsep{\fill}}}
              add1	&	dummy.coef	\\
              alias	&	effects	\\
              confint	&	kappa	\\
              dfbeta	&	predict	\\
              dfbetas	&	proj	\\
              drop1	&		\\
          \end{tabular*}
        }
    \end{fbox}
    \caption{Generic functions in the \Rpackage{base}, \Rpackage{stats} and
      \Rpackage{graphics} packages for which methods have been written for
      \Rclass{glm} or \Rclass{lm} objects, but which are \emph{not}
      implemented for \Rclass{gnm} objects.}
    \label{!glm.lm}
\end{figure}

In addition to the accessor functions shown in Figure \ref{glm.lm}, the
\Rpackage{gnm} package provides a new generic function called
\Rfunction{termPredictors}
that has methods for objects of class \Rclass{gnm}, \Rclass{glm} and
\Rclass{lm}. This function returns the additive contribution of each term to
the predictor.  See Section \ref{glms} for an example of its use.

Most of the methods listed in Figure \ref{glm.lm} can be used as they would be
for \Rclass{glm} or \Rclass{lm} objects, however care must be taken with
\Rmethod{vcov}, as the variance-covariance matrix will depend on the
parameterisation of the model. In particular, standard errors calculated using
the variance-covariance matrix will only be valid for parameters or contrasts
that are estimable!

The \Rfunction{checkEstimable} function can be used to check the estimability of
contrasts. Consider the following model, that is described later in Section
\ref{Unidiff}:
<<Double_UNIDIFF_model>>=
data(cautres)
doubleUnidiff <- gnm(Freq ~ election:vote + election:class:religion
                     + Mult(Exp(election - 1), religion:vote - 1) +
                     Mult(Exp(election - 1), class:vote - 1), family = poisson,
                     data = cautres)
@
The effects of the first constituent multiplier in the first multiplicative
interaction are identified when the estimate of one of these effects is constrained to
zero, say for the effect of the last level. The parameters to be estimated are
then the differences between each effect and the effect of the last level. These
differences can be represented by a contrast matrix as follows:
<<Contrast_matrix>>=
coefs <- names(coef(doubleUnidiff))
contrCoefs <- coefs[grep("Mult1.Factor1", coefs)]
contrMatrix <- matrix(0, length(coefs), length(contrCoefs),
                      dimnames = list(coefs, contrCoefs))
contrMatrix[contrCoefs, 1:(ncol(contrMatrix) - 1)] <- contr.sum(contrCoefs)
contrMatrix[contrCoefs, 1:(ncol(contrMatrix) - 1)]
@
Then their estimability can be checked using \Rfunction{checkEstimable}
<<Check_estimability_1>>=
checkEstimable(doubleUnidiff, contrMatrix)
@
which confirms that the effects for the other three levels are estimable when
the effect for the last level is set to zero.

However, applying the equivalent constraint to the second constituent
multiplier in the
interaction is not sufficient to make the parameters in that multiplier
estimable:
<<Check_estimability_2>>=
coefs <- names(coef(doubleUnidiff))
contrCoefs <- coefs[grep("Mult1.Factor2", coefs)]
contrMatrix <- matrix(0, length(coefs), length(contrCoefs),
                      dimnames = list(coefs, contrCoefs))
contrMatrix[contrCoefs, 1:(ncol(contrMatrix) - 1)] <- contr.sum(contrCoefs)
checkEstimable(doubleUnidiff, contrMatrix)
@

To investigate simple ``sum to zero'' contrasts such as those above, it
is easiest to use the \Rfunction{getContrasts} function, which checks the
estimability of the contrasts and returns the parameter estimates with their
standard errors. Returning to the example of the first constituent multiplier
in the first
multiplicative interaction term, the differences between each election
and the last can be obtained as follows:
<<Get_contrasts_1>>=
coefs.of.interest <- grep("Mult1.Factor1", names(coef(doubleUnidiff)))
getContrasts(doubleUnidiff, coefs.of.interest)
@ %def
Attempting to obtain the equivalent contrasts for the second
(religion-vote association) multiplier produces the
following result:
<<Get_contrasts_2>>=
coefs.of.interest <- grep("Mult1.Factor2", names(coef(doubleUnidiff)))
getContrasts(doubleUnidiff, coefs.of.interest)
@ %def

\section{Examples}
\label{Examples}

This section provides some examples of the wide range of models that may be fitted
using the \Rpackage{gnm} package. Sections \ref{RCmodels}, \ref{Dref} and
\ref{Unidiff} consider various models for contingency tables; Section
\ref{GAMMI} considers AMMI and GAMMI models which are typically used in
agricultural applications, and Section \ref{Stereotype} considers the stereotype
model, which is used to model an ordinal response.

\subsection{Row-column Association Models}
\label{RCmodels}

There are several models that have been proposed for modelling the relationship
between the cell means of a contingency table and the cross-classifying
factors. The following examples consider the row-column association models
proposed by \citet{Good79}. The examples shown use data from two-way contingency
tables, but the \Rpackage{gnm} package can also be used to fit the equivalent
models for higher order tables.

\subsubsection{RC(1) model}

The RC(1) model is a row and column association model with the interaction
between row and column factors represented by one component of the
multiplicative
interaction. If the rows are indexed by $r$ and the columns by $c$, then the
log-multiplicative form of the RC(1) model for the cell means $\mu_{rc}$ is
given by
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c. \]

We shall fit this model to the \Robject{mentalHealth} data set taken from
\citet{Agre02} page 381, which is a two-way contingency table classified
by the child's
mental impairment (MHS) and the parents' socioeconomic status (SES). Although
both of these factors are ordered, we do not wish to use polynomial contrasts
in the model, so we begin by setting the contrasts attribute of these
factors to \Robject{``treatment''}:
<<Set_contrasts_attribute>>=
set.seed(1)
data(mentalHealth)
mentalHealth$MHS <- C(mentalHealth$MHS, treatment)
mentalHealth$SES <- C(mentalHealth$SES, treatment)
@
The \Rclass{gnm} model is then specified as follows, using the poisson family
with a log link function:
<<RC1_model>>=
RC1model <- gnm(count ~ SES + MHS + Mult(-1 + SES, -1 + MHS),
                family = poisson, data = mentalHealth)
RC1model
@ %def
The row scores (parameters 10 to 15) and the column scores (parameters 16 to 19)
of the multiplicative interaction can be normalized as in Agresti's eqn (9.15):
<<Normalize_scores>>=
rowProbs <- with(mentalHealth, tapply(count, SES, sum) / sum(count))
colProbs <- with(mentalHealth, tapply(count, MHS, sum) / sum(count))
rowScores <- coef(RC1model)[10:15]
colScores <- coef(RC1model)[16:19]
rowScores <- rowScores - sum(rowScores * rowProbs)
colScores <- colScores - sum(colScores * colProbs)
beta1 <- sqrt(sum(rowScores^2 * rowProbs))
beta2 <- sqrt(sum(colScores^2 * colProbs))
assoc <- list(beta = beta1 * beta2,
              mu = rowScores / beta1,
              nu = colScores / beta2)
assoc
@ %def

\subsubsection{RC(2) model}

The RC(1) model can be extended to an RC($m$) model with $m$ components of the
multiplicative interaction. For example, the RC(2) model is given by
\[
\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c + \theta_r\phi_c.
\]
Extra instances of the multiplicative interaction can be specified by the
\Rfunarg{multiplicity} argument of \Rfunction{Mult}, so the RC(2) model can be
fitted to the \Robject{mentalHealth} data as follows
<<RC2_model>>=
RC2model <- gnm(count ~ SES + MHS +
                Mult(-1 + SES, -1 + MHS, multiplicity = 2),
                family = poisson, data = mentalHealth)
RC2model
@

\subsubsection{Homogeneous effects}

If the row and column factors have the same levels, or perhaps some levels in
common, then the row-column interaction could be modelled by a multiplicative
interaction with homogeneous effects, that is
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\gamma_c.\]
For example, the \Robject{occupationalStatus} data set from \citet{Good79} is a
contingency table classified by the occupational status of fathers (origin) and
their sons (destination). \citet{Good79} fits a row-column association model
with homogeneous effects to these data after deleting the cells on the main
diagonal. Equivalently we can account for the diagonal effects by a separate
\Rfunction{Diag} term:
@
<<Homogeneous_effects>>=
data(occupationalStatus)
RChomog <- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               Nonlin(MultHomog(origin, destination)), family = poisson,
               data = occupationalStatus)
RChomog
@ %def

To determine whether it would be better to allow for heterogeneous effects on
the association of the fathers' occupational status and the sons' occupational
status, we can compare this model to the RC(1) model for these data:
<<Heterogeneous_effects>>=
data(occupationalStatus)
RCheterog <- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               Mult(origin, destination), family = poisson,
               data = occupationalStatus)
RChomog$dev - RCheterog$dev
RChomog$df.residual - RCheterog$df.residual
@
In this case there is little gain in allowing heterogeneous effects.

\subsection{Diagonal Reference Models}
\label{Dref}

Diagonal reference models, proposed by \citet{Sobe81, Sobe85}, are designed for
contingency tables classified by factors with the same levels. The cell
means are modelled as a function of the diagonal effects, i.e., the mean
responses of the `diagonal' cells in which the levels of the row and
column factors are the same.

\subsubsection*{\Rfunction{Dref} example 1: Political consequences of 
social mobility}

To illustrate the use of diagonal reference models we shall use the
\Robject{voting} data from \citet{Clif93}. The data come from the 1987 British
general election and are the percentage voting Labour in groups cross-classified
by the class of the head of household (\Robject{destination}) and the class of
their father (\Robject{origin}). In order to weight these percentages by the
group size, we first back-transform them to the counts of those voting Labour
and those not voting Labour: 
@ 
<<Transform_to_counts>>=
set.seed(1)
data(voting)
count <- with(voting, percentage/100 * total)
yvar <- cbind(count, voting$total - count)
@ %def 

The grouped percentages may be modelled by a basic diagonal reference model, that
is, a weighted sum of the diagonal effects for the corresponding origin and
destination classes. This model may be expressed as
\[
\mu_{od} = \frac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_o +
\frac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_d .
\]
See Section \ref{NonlinDref} for more detail on the parameterisation. 

The basic diagonal reference model may be fitted using \Rfunction{gnm} as
follows 
@ 
<<Class_mobility>>=
classMobility <- gnm(yvar ~ Nonlin(Dref(origin, destination)), 
                       family = binomial, data = voting)
classMobility
@ %def 
and the origin and destination weights can be evaluated as below
@ 
<<Class_mobility_weights>>=
prop.table(exp(coef(classMobility)[2:3]))
@ %def 
This model is slightly different from that reported by \citet{Clif93}.  The reason 
for this is unclear: we are confident that the above results are correct for the
data as given in \citet{Clif93}, but have not been able to confirm that the data
as printed in the journal were exactly as used in Clifford and Heath's 
analysis.

\citet{Clif93} suggest that movements in and out of the salariat (class 1)
should be treated differently from movements between the lower classes (classes
2 - 5), since the former has a greater effect on social status. Thus they 
propose the following model
\begin{equation*}
\mu_{od} = \begin{cases}
\dfrac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_o +
\dfrac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_d & \text{if } i = 1\\
\\
\dfrac{e^{\delta_3}}{e^{\delta_3} + e^{\delta_4}}\gamma_o +
\dfrac{e^{\delta_4}}{e^{\delta_3} + e^{\delta_4}}\gamma_d & \text{if } j = 1\\
\\
\dfrac{e^{\delta_5}}{e^{\delta_5} + e^{\delta_6}}\gamma_o +
\dfrac{e^{\delta_6}}{e^{\delta_5} + e^{\delta_6}}\gamma_d & \text{if } i \ne 1
\text{ and } j \ne 1
\end{cases}
\end{equation*}
To fit this model we define factors indicating movement in (upward) and out
(downward) of the salariat
@ 
<<Salariat_factors>>=
upward <- with(voting, origin != 1 & destination == 1)
downward <- with(voting, origin == 1 & destination != 1)
@ %def 
Then the diagonal reference model with separate weights for socially mobile
groups can be estimated as follows
@ 
<<Social_mobility>>=
socialMobility <- gnm(yvar ~ Nonlin(Dref(origin, destination,
                                         formula = ~ 1 + downward + upward)),
                      family = binomial, data = voting)
socialMobility
@ %def 
The weights for those moving into the salariat, those moving out of the
salariat and those in any other group, can be evaluated as below
@ 
<<social_mobility_weights>>=
prop.table(exp(coef(socialMobility)[c(4, 7)] + coef(socialMobility)[c(2, 5)]))
prop.table(exp(coef(socialMobility)[c(3, 6)] + coef(socialMobility)[c(2, 5)]))
prop.table(exp(coef(socialMobility)[c(2, 5)]))
@ %def
Again, the results differ slightly from those reported by \citet{Clif93}, but
the essence of the results is the same: the origin weight is much larger for the
downwardly mobile groups than for the other groups. The weights for the upwardly
mobile groups are very similar to the base level weights, so the model may be
simplified by only fitting separate weights for the downwardly mobile groups:
@ 
<<Downward_mobility>>=
downwardMobility <- gnm(yvar ~ Nonlin(Dref(origin, destination,
                                           formula = ~ 1 + downward)),
                        family = binomial, data = voting)
downwardMobility
prop.table(exp(coef(downwardMobility)[c(3, 5)] + 
               coef(downwardMobility)[c(2, 4)]))
prop.table(exp(coef(downwardMobility)[c(2, 4)]))
@ %def 

\subsubsection*{\Rfunction{Dref} example 2: Conformity to parental rules} 

%\SweaveInput{vanDerSlikEg.Rnw}

Another application of diagonal reference models is given by
\citet{Vand02}. The data from this paper are not publicly available\footnote{
We thank Frans van der Slik for his kindness in sending us the data.}, but we
shall show how the models presented in the paper may be estimated using
\Rfunction{gnm}. 

The data relate to the value parents place on their children conforming to their
rules. There are two response variables: the mother's conformity score (MCFM)
and the father's conformity score (FCFF). The data are cross-classified by two
factors describing the education level of the mother (MOPLM) and the father
(FOPLF), and there are six further covariates (AGEM, MRMM, FRMF, MWORK, MFCM and
FFCF). 

In their baseline model for the mother's conformity score, \citet{Vand02}
include five of the six covariates (leaving out the father's family conflict
score, FCFF) and a diagonal reference term with constant weights based on the
two education factors. This model may be expressed as
\[
\mu_{rc} = \beta_1x_1 + \beta_2x_2 + \beta_3x_3 +\beta_4x_4 +\beta_5x_5 +
\frac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_r +
\frac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_c .
\]

The baseline model can be fitted as follows:
\begin{alltt}
> set.seed(1)
> A <- gnm(MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM +
+          Nonlin(Dref(MOPLM, FOPLF)), family = gaussian, data = conformity,
+          verbose = FALSE)
> A

Call:
gnm(formula = MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM + 
    Nonlin(Dref(MOPLM, FOPLF)), family = gaussian, data = conformity,
    verbose = FALSE)


Coefficients:
                    AGEM                      MRMM                      FRMF  
                 0.06364                  -0.32425                  -0.25324  
                   MWORK                      MFCM  Dref(MOPLM, FOPLF).MOPLM  
                -0.06430                  -0.06043                   0.34389  
Dref(MOPLM, FOPLF).FOPLF      Dref(MOPLM, FOPLF).1      Dref(MOPLM, FOPLF).2  
                 0.65611                   4.95123                   4.86328  
    Dref(MOPLM, FOPLF).3      Dref(MOPLM, FOPLF).4      Dref(MOPLM, FOPLF).5  
                 4.86458                   4.72342                   4.43516  
    Dref(MOPLM, FOPLF).6      Dref(MOPLM, FOPLF).7  
                 4.18873                   4.43379  

Deviance:            425.3389 
Pearson chi-squared: 425.3389 
Residual df:         576
\end{alltt}
Due to the constraints imposed on the weights in the diagonal reference term,
the coefficients of model \Robject{A} are the unique solutions. Therefore
these estimates should correspond to those reported in Table 4 of
\citet{Vand02}. The weights in the diagonal reference term can be evaluated as
follows:
\begin{alltt}
> prop.table(exp(coef(A)[6:7]))
Dref(MOPLM, FOPLF).MOPLM Dref(MOPLM, FOPLF).FOPLF 
               0.4225734                0.5774266 
\end{alltt}
giving the values reported by \citet{Vand02}. All the other coefficients of
model A are the same as those reported by \citet{Vand02} except the coefficients
of the mother's gender role (MRMM) and the father's gender role
(FRMF). \citet{Vand02} reversed the signs of the coefficients of these factors
since they were coded in the direction of liberal values, unlike the other
covariates. However, simply reversing the signs of these coefficients does not
give the same model, since the estimates of these coefficients are not
independent of the estimates of the diagonal effects. For consistent
interpretation of the covariate coefficients, it is better to recode the gender
role factors as follows:
\begin{alltt}
> MRMM2 <- as.numeric(!conformity$MRMM)
> FRMF2 <- as.numeric(!conformity$FRMF)
> A <- gnm(MCFM ~ -1 + AGEM + MRMM2 + FRMF2 + MWORK + MFCM +
+          Nonlin(Dref(MOPLM, FOPLF)), family = gaussian, data = conformity,
+          verbose = FALSE)
> A

Call:
gnm(formula = MCFM ~ -1 + AGEM + MRMM2 + FRMF2 + MWORK + MFCM + 
    Nonlin(Dref(MOPLM, FOPLF)), family = gaussian, data = conformity,
    verbose = FALSE)


Coefficients:
                    AGEM                     MRMM2                     FRMF2  
                 0.06364                   0.32425                   0.25324  
                   MWORK                      MFCM  Dref(MOPLM, FOPLF).MOPLM  
                -0.06430                  -0.06043                   0.34389  
Dref(MOPLM, FOPLF).FOPLF      Dref(MOPLM, FOPLF).1      Dref(MOPLM, FOPLF).2  
                 0.65611                   4.37373                   4.28578  
    Dref(MOPLM, FOPLF).3      Dref(MOPLM, FOPLF).4      Dref(MOPLM, FOPLF).5  
                 4.28708                   4.14593                   3.85766  
    Dref(MOPLM, FOPLF).6      Dref(MOPLM, FOPLF).7  
                 3.61123                   3.85629  

Deviance:            425.3389 
Pearson chi-squared: 425.3389 
Residual df:         576
\end{alltt}
The coefficients of the covariates are now as reported by \citet{Vand02}, but
the diagonal effects have been adjusted appropriately.

\citet{Vand02} compare the baseline model for the mother's conformity score to
several other models in which the weights in the diagonal reference term are
dependent on one of the covariates. One particular model they consider
incorporates an interaction of the weights with the mother's conflict score as
follows:
\[
\mu_{rc} = \beta_1x_1 + \beta_2x_2 + \beta_3x_3 +\beta_4x_4 +\beta_5x_5 +
\frac{e^{\xi_1 + \beta_1x}}{e^{\xi_1 + \beta_1x} +
e^{\xi_2 + \beta_2x}}\gamma_r + \frac{e^{\xi_2 + \beta_2x}}{e^{\xi_1 + \beta_1x}
+ e^{\xi_2 + \beta_2x}}\gamma_c.
\]

This model can be fitted as below, using the original coding for the gender
role factors for ease of comparison to the results reported by \citet{Vand02},
\begin{alltt}
> F <- gnm(MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM +
+          Nonlin(Dref(MOPLM, FOPLF, formula = ~ 1 + MFCM)), family = gaussian,
+          data = conformity, verbose = FALSE)
> F

Call:
gnm(formula = MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM + 
    Nonlin(Dref(MOPLM, FOPLF, formula = ~1 + MFCM)), family = gaussian, 
    data = conformity, verbose = FALSE)


Coefficients:
                                                     AGEM  
                                                  0.05818  
                                                     MRMM  
                                                 -0.32701  
                                                     FRMF  
                                                 -0.25772  
                                                    MWORK  
                                                 -0.07847  
                                                     MFCM  
                                                 -0.01694  
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).MOPLM.(Intercept)  
                                                  1.03516  
       Dref(MOPLM, FOPLF, formula = ~1 + MFCM).MOPLM.MFCM  
                                                 -1.77703  
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).FOPLF.(Intercept)  
                                                 -0.03516  
       Dref(MOPLM, FOPLF, formula = ~1 + MFCM).FOPLF.MFCM  
                                                  2.77703  
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).1  
                                                  4.82477  
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).2  
                                                  4.88066  
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).3  
                                                  4.83969  
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).4  
                                                  4.74849  
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).5  
                                                  4.42019  
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).6  
                                                  4.17956  
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).7  
                                                  4.40819  

Deviance:            420.9022 
Pearson chi-squared: 420.9022 
Residual df:         575 
\end{alltt}
In this case there are two sets of weights, one for when the mother's conflict
score is less than average (coded as zero) and one for when the score is greater
than average (coded as one). These can be evaluated as follows:
\begin{alltt}
> prop.table(exp(coef(F))[c(6,8)])
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).MOPLM.(Intercept) 
                                                0.7446585 
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).FOPLF.(Intercept) 
                                                0.2553415 
> prop.table(exp(coef(F)[c(7,9)] + coef(F)[c(6,8)]))
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).MOPLM.MFCM 
                                        0.02977851 
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).FOPLF.MFCM 
                                        0.97022149 
\end{alltt}
giving the same weights as in Table 4 of \citet{Vand02}.

\subsection{Uniform Difference (UNIDIFF) Models}
\label{Unidiff}

Uniform difference models \citep{Xie92, Erik92} use a simplified three-way
interaction to provide an interpretable model of contingency tables classified
by three or more variables. For example, the uniform difference model for a
three-way contingency table, also known as the UNIDIFF model, is given by
\[
\mu_{ijk} = \alpha_{ik} + \beta_{jk} + \exp(\delta_k)\gamma_{ij}.
\]
The $\gamma_{ij}$ represent a pattern of association that varies in strength
over the dimension indexed by $k$, and $\exp(\delta_k)$ represents the relative
strength of that association at level $k$.

This model can be applied to the \Robject{yaish} data set 
\citep{Yais98,Yais04}, 
which is a
contingency table cross-classified by father's social class (\Robject{orig}),
son's social
class (\Robject{dest}) and son's education level (\Robject{educ}).
In this case, we can consider the
importance of the association between the social class of father and son across
the education levels:
@
<<UNIDIFF_model>>=
set.seed(1)
data(yaish)
unidiff <- gnm(Freq ~ educ:orig + educ:dest +
               Mult(Exp(-1 + educ), orig:dest), family = poisson,
               data = yaish)
coefs.of.interest <- grep("Mult1.Factor1", names(coef(unidiff)))
coef(unidiff)[coefs.of.interest]
@ %def
The \Robject{coefs.of.interest} are the multipliers of the association between
the social class of father and son. We can contrast each multiplier to that of
the highest education level and obtain the standard errors for these parameters
as follows:
@
<<Unidiff_contrasts>>=
getContrasts(unidiff, coefs.of.interest)
@ %def

Four-way contingency tables may sometimes be described by a
``double UNIDIFF'' model
\[
\mu_{ijkl} = \alpha_{il} + \beta_{jkl} + \exp(\delta_l)\gamma_{ij} +
\exp(\phi_l)\theta_{ik},
\]
where the strengths of two, two-way associations with a common variable are
estimated across the levels of the fourth variable.
The \Robject{cautres} data set, from \citet{Caut98}, can be used to illustrate 
the application of the
double UNIDIFF model. This data set is classified by the variables vote, class,
religion and election. Using a double UNIDIFF model, we can see how the
association between class and vote, and the association between religion and
vote, differ between the most recent election and the other elections:
@
<<double_UNIDIFF_model>>=
set.seed(1)
data(cautres)
doubleUnidiff <- gnm(Freq ~ election:vote + election:class:religion +
                     Mult(Exp(-1 + election), religion:vote) +
                     Mult(Exp(-1 + election), class:vote),
                     family = poisson, data = cautres)
getContrasts(doubleUnidiff, grep("Mult1.Factor1", names(coef(doubleUnidiff))))
getContrasts(doubleUnidiff, grep("Mult2.Factor1", names(coef(doubleUnidiff))))
@ %def

\subsection{Generalized Additive Main Effects and
Multiplicative Interaction (GAMMI) Models}
\label{GAMMI}

Generalized additive main effects and multiplicative interaction models, or
GAMMI models, were motivated by two-way contingency tables and comprise the row
and column main effects plus one or more components of the multiplicative
interaction. The singular value corresponding to each multiplicative component
is often factored out, as a measure of the strength of association between the
row and column scores, indicating the importance of the component, or axis.

For cell means $\mu_{rc}$ a GAMMI-K model has the form
\[
g(\mu_{rc}) = \alpha_r + \beta_c + \sum_{k=1}^K
\sigma_k\gamma_{kr}\delta_{kc},
\]
in which $g$ is a link function, $\alpha_r$ and $\beta_c$ are the row and column
main effects, $\gamma_{kr}$ and $\delta_{kc}$ are the row and column scores for
multiplicative component $k$ and $\sigma_k$ is the singular value for component
$k$. The number of multiplicative components, $K$, is less than or equal to the
rank of the matrix of residuals from the main effects.

The row-column association models discussed in Section \ref{RCmodels} are
examples of GAMMI models, with a log link and poisson variance. Here we
illustrate the use of an AMMI model, which is a GAMMI model with an identity
link and a constant variance.

We shall use the \Robject{wheat} data set taken from \citet{Varg01}, which gives
wheat yields measured over ten years. First we scale these yields and
create a new treatment factor, so that we can reproduce the analysis of
\citet{Varg01}:
@
<<Scale_yields>>=
set.seed(1)
data(wheat)
yield.scaled <- wheat$yield * sqrt(3/1000)
treatment <- interaction(wheat$tillage, wheat$summerCrop, wheat$manure,
                         wheat$N, sep = "")
@ %def
Now we can fit the AMMI-1 model, to the scaled yields using the combined
treatment factor and the year factor from the \Robject{wheat} dataset:
@
<<AMMI_model>>=
bilinear1 <- gnm(yield.scaled ~ year + treatment + Mult(year, treatment),
                 family = gaussian, data = wheat)
@ %def
and compare the AMMI-1 model to the main effects model
@
<<AOD>>=
mainEffects <- glm(yield.scaled ~ year + treatment, family = gaussian,
                   data = wheat)
anova(mainEffects, bilinear1)
@ %def
giving the same results as in Table 1 of \citet{Varg01} (up to error caused by
rounding).

\subsection{Biplot Models}

Biplots are used to display two-dimensional data transformed into a space
spanned by linearly independent vectors, such as the principal components or
singular vectors. The plot represents the levels of the two classifying
factors by
their scores on the two axes which show the most information about the data, for
example the first two principal components.

A rank-$n$ model is a model based on the first $n$ components of the
decomposition. In the case of a singular value decomposition, this is equivalent
to a model with $n$ components of the multiplicative interaction.

To illustrate the use of biplot models, we shall use the \Robject{barley} data
set which describes the incidence of leaf blotch over ten varieties of barley
grown at nine sites \citep{Wedd74,Gabr98}. The biplot model is fitted as
follows:
@
<<Biplot_model>>=
data(barley)
set.seed(1)
biplotModel <- gnm(y ~ -1 + Mult(site, variety, multiplicity = 2),
                   family = wedderburn, data = barley)
@ %def
using the \Rfunction{wedderburn} family function introduced in Section
\ref{glms}. Matrices of the row and column scores for the first two singular
vectors can then be obtained by:
@
<<Row_and_column_scores>>=
barleySVD <- svd(matrix(biplotModel$predictors, 10, 9))
A <- sweep(barleySVD$v, 2, sqrt(barleySVD$d), "*")[, 1:2]
B <- sweep(barleySVD$u, 2, sqrt(barleySVD$d), "*")[, 1:2]
A
B
@ %def
These matrices are essentially the same as in \citet{Gabr98}. From these the
biplot can be produced, for sites $A \ldots I$ and varieties $1 \dots 9, X$:
\begin{center}
@
<<Biplot, fig = TRUE>>=
plot(rbind(A, B), pch = c(levels(barley$site), levels(barley$variety)),
     xlim = c(-4, 4), ylim = c(-4, 4), main = "Biplot for barley data")
@ %Def
\end{center}
The product of the matrices
\Robject{A} and \Robject{B}
is unaffected by rotation or reciprocal scaling along either axis,
so we can rotate the data so that the points for the sites are roughly parallel
to the horizontal axis and the points for the varieties are roughly parallel to
the vertical axis. In addition, we can scale the data so that points for the
sites are about the line one unit about the horizontal axis, roughly
\begin{center}
@
<<Rotate_and_scale, fig = TRUE>>=
a <- pi/5
rotation <- matrix(c(cos(a), sin(a), -sin(a), cos(a)), 2, 2, byrow = TRUE)
rA <- (2 * A/3) %*% rotation
rB <- (3 * B/2) %*% rotation
plot(rbind(rA, rB), pch = c(levels(barley$site), levels(barley$variety)),
     xlim = c(-4, 4), ylim = c(-4, 4),
     main = "Biplot (rotated) for barley data")
@ %def
\end{center}
In the original biplot, the co-ordinates for the sites and varieties were given
by the rows of A and B respectively, i.e
\begin{eqnarray*}
\alpha_i^T &= \sqrt(d)(u_{1i}, u_{2i})\\
\beta_j^T &= \sqrt(d)(v_{1j}, v_{2j})
\end{eqnarray*}
The rotated and scaled biplot suggests the simpler model
\begin{eqnarray*}
\alpha_i^T &= (\gamma_i, 1) \\
\beta_j^T &= (\delta_j, \tau_j)
\end{eqnarray*}
which implies the following model for the logits of the leaf blotch incidence:
\[\alpha_i^T\beta_j = \gamma_i\delta_j + \tau_j.\]
\citet{Gabr98} describes this as a double additive model, which we can fit as
follows:
@
<<Double_additive>>=
variety.binary <- factor(match(barley$variety, c(2,3,6), nomatch = 0) > 0,
                        labels = c("rest", "2,3,6"))
doubleAdditive <- gnm(y ~ variety + Mult(site, variety.binary),
                      family = wedderburn, data = barley)
@ %def
Comparing the chi-squared statistics, we see that the double additive model is
an adequate model for the leaf blotch incidence:
@
<<Compare_chi-squared>>=
biplotModChiSq <- sum(residuals(biplotModel, type = "pearson")^2)
doubleAddChiSq <- sum(residuals(doubleAdditive, type = "pearson")^2)
c(doubleAddChiSq - biplotModChiSq,
  doubleAdditive$df.residual - biplotModel$df.residual)
@ %def

\subsection{Stereotype Model}
\label{Stereotype}

The stereotype model was proposed by \citet{Ande84} for ordered categorical
data. It is a linear logistic model, in which there is assumed to be a common
relationship between the response and the covariates in the model, but the
scale of this association varies between categories and there is an additional
category main effect or category-specific intercept:
\[
\log \mu_{ic} =  \beta_{0c} + \gamma_c\sum_r \beta_{rc}x_{ir}.
\]
This model can be estimated by re-expressing the categorical data as counts and
using a \Rclass{gnm} model with a log link and poisson variance function.

For example, the \Robject{backPain} data set from \citet{Ande84} describes the
progress of patients with back pain. The data set consists of an ordered factor
quantifying the progress of each patient, and three prognostic variables. These
data can be re-expressed as follows:
@
<<Re-express_data>>=
set.seed(1)
data(backPain)
backPain[1:2,]
library(nnet)
.incidence <- class.ind(backPain$pain)
.counts <- as.vector(t(.incidence))
.rowID <- factor(t(row(.incidence)))
backPain <- backPain[.rowID, ]
backPain$pain <- C(factor(rep(levels(backPain$pain), nrow(.incidence)),
                          levels = levels(backPain$pain), ordered = TRUE),
                   treatment)
cbind(.rowID[1:12], .counts[1:12], backPain[1:12,4:1])
@ %def
We can now fit the stereotype model to these data:
@
<<Stereotype_model>>=
oneDimensional <- gnm(.counts ~ pain + Mult(pain - 1, x1 + x2 + x3 - 1),
                      eliminate = ~ .rowID, family = "poisson", data = backPain,
                      iterStart = 3)
oneDimensional
@ %def
using \Rfunarg{eliminate} to handle the \Robject{.rowID} so that
these structural parameters do
not appear in the returned coefficients. This model is one dimensional since it
involves only one function of $\mathbf{x} = (x1, x2, x3)$. We can compare this
model to one with category-specific coefficents of the $x$ variables, as may be
used for a qualitative categorical response:
@
<<Qualitative_model>>=
threeDimensional  <- gnm(.counts ~ pain + pain:(x1 + x2 + x3),
                         eliminate = ~ .rowID, family = "poisson",
                         data = backPain)
threeDimensional
@ %def
This model has the maximum dimensionality of three (as determined by the number
of covariates). To obtain the log-likelihoods as reported in \citet{Ande84} we
need to adjust for the extra parameters introduced to formulate the models as
Poisson models. We write a simple function to do this and compare the
log-likelihoods of the one dimensional model and the three dimensional model:
@
<<Calculate_log-likelihood>>=
logLikMultinom <- function(model){
    object <- get(model)
    if (inherits(object, "gnm")) {
        l <- logLik(object) + object$eliminate
        c(nParameters = attr(l, "df") - object$eliminate, logLikelihood = l)
    }
    else
        c(nParameters = object$edf, logLikelihood = -deviance(object)/2)
}
t(sapply(c("oneDimensional", "threeDimensional"), logLikMultinom))
@ %def
which show that the \Robject{oneDimensional} model is adequate.





\newpage
\appendix

\section{User-level Functions}

We list here, for easy reference, all of the user-level functions in the
\Rpackage{gnm} package.  For full documentation see the package help pages.

\begin{table}[!h]
\begin{tabular*}{\textwidth}{@{}p{0.2in}p{1.3in}p{4.5in}@{}}
    \toprule
    \multicolumn{3}{l}{\textbf{Model Fitting}} 	\\
    \midrule
    &	\Rfunction{gnm}	&  fit generalized nonlinear models	\\
    &	\Rfunction{gnmControl}	&  set control parameters for fitting
                                   \Rclass{gnm} models	\\
    \midrule
    \multicolumn{3}{l}{\textbf{Model Specification}}			\\
    \midrule
    &	\Rfunction{Diag}	&  create factor differentiating
                                   diagonal elements \\
    &	\Rfunction{Symm}	&  create symmetric interaction of factors \\
    &   \Rfunction{Topo}        &  create `topological' interaction factors \\
    &	\Rfunction{Mult}	&  specify a multiplicative interaction in a
                                   \Rfunction{gnm} formula	\\
    &	\Rfunction{Exp}	&  specify an exponentiated constituent multiplier in a
                           \Rfunction{Mult} term	\\
    &	\Rfunction{Nonlin}	&  specify a special nonlinear term in a
                                   \Rfunction{gnm} formula	\\
    &	\Rfunction{Dref}	&  gnm plug-in function to fit diagonal
                                   reference terms \\
    &	\Rfunction{MultHomog}	&  gnm plug-in function to fit multiplicative
                                   interactions with homogeneous effects	\\
    &   \Rfunction{wedderburn}      &  specify the Wedderburn
                                       quasi-likelihood family \\
    \midrule
    \multicolumn{3}{l}{\textbf{Methods and Accessor Functions}}	\\
    \midrule
    &	\Rmethod{summary.gnm}	&  summarize \Rclass{gnm} fits	\\
    &	\Rfunction{getContrasts}	&  estimate contrasts and their
                                           standard errors for parameters in a gnm
                                           model \\
    &	\Rfunction{checkEstimable}	&  check whether one or more parameter
                                           combinations in a
                                           \Rclass{gnm} model is identified \\
    &	\Rfunction{se}	&  get standard errors of linear parameter
                           combinations in \Rclass{gnm} models	\\
    &	\Rfunction{termPredictors}	&  (\emph{generic}) extract term
                                           contributions to predictor	\\
    \midrule
    \multicolumn{3}{l}{\textbf{Auxiliary Functions}}			\\
    \midrule
    &	\Rfunction{getModelFrame}	&  get the model frame in use by
                                           \Rfunction{gnm}	\\
    &	\Rfunction{MPinv}	&  Moore-Penrose pseudoinverse of a
                                   real-valued matrix	\\
\end{tabular*}
\end{table}

\newpage
\section{Key Changes since Last Release}

The new features, improvements and changes in behaviour since the last release
are given below. For bug fixes since the last release and the changes made in
previous releases, see the CHANGES file in the package directory.

\begin{verbatimtab}

Changes in gnm 0.7-2
=======================

Improvements
------------

    o	Extended use of the 'eliminate' argument of gnm() to allow crossed 
	factors - this also fixes bug which occurred when interactions were 
	eliminated in the presence of lower order terms involving other factors 

Changes in Behaviour
--------------------

    o	'vcov' returned by gnm() now has no rank attribute (as before, the
	rank is returned as the separate component 'rank').
\end{verbatimtab}

\newpage
\bibliography{gnm}
\bibliographystyle{chicago}

\end{document}
